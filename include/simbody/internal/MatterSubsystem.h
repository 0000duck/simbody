#ifndef SimTK_MATTER_SUBSYSTEM_H_
#define SimTK_MATTER_SUBSYSTEM_H_

/* Portions copyright (c) 2005-7 Stanford University and Michael Sherman.
 * Contributors: Paul Mitiguy
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including 
 * without limitation the rights to use, copy, modify, merge, publish, 
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS, CONTRIBUTORS, OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include "SimTKcommon.h"
#include "simbody/internal/common.h"
#include "simbody/internal/Subsystem.h"
#include "simbody/internal/MobilizedBody.h"

namespace SimTK {

/**
 * The still-abstract parent of all MatterSubsystems (such as the
 * one generated by Simbody). This is derived from Subsystem.
 *
 * The MatterSubsystem class implements a friendlier API on top of
 * the efficient, minimalist interface required of concrete MatterSubsystem
 * implementation classes (such as SimbodyMatterSubsystem). In many cases
 * these are inline implementations, but some performance
 * tradeoffs are made in this API in the interest of beauty and simplicity. These
 * are expected to be insignificant in most applications but if (after measurement!)
 * you determine that these are a bottleneck you are always welcome to call
 * directly into the part of the interface which is directly implemented by
 * the concrete class. The concrete class methods are defined after the 
 * friendly one below.
 *
 * This API was designed by Paul Mitiguy and Michael Sherman to address
 * the anticipated needs of Paul's BMI 215 students at Stanford. However,
 * we expect it will be useful for many other purposes.
 */
class SimTK_SIMBODY_EXPORT MatterSubsystem : public Subsystem {
public:
    //////////////////
    // CONSTRUCTION //
    //////////////////

    // Primarily, this abstract MatterSubsystem expects construction to have been
    // done on the concrete MatterSubsystem (e.g., SimbodyMatterSubsystem) which implements
    // this one. That's because we're assuming that different implementations will have
    // different ways to set up the bodies, their mobilizers, and constraints.
    // For less-significant objects in a MatterSubsystem, such as visualization geometry,
    // labels and so on, we provide methods here. These can be used either by the 
    // user or by the underlying implementation.


    /// Enable or suppress the generation of a default visualization skeleton by the
    /// MatterSubsystem. This is on by default and includes body and mobilizer frames,
    /// body center of mass markers, and lines connecting the frames on each body.
    /// TODO: should include ellipsoids oriented along principal moments of inertia,
    /// and maybe some labels.
    void setSuppressDefaultGeometry(bool);

    /// Add a decoration which is always present, and is at a fixed location on a particular
    /// body. The passed-in DecorativeGeometry is used as a prototype for the desired decoration,
    /// with the supplied transform composed with whatever transform is already there, and the
    /// supplied bodyId overriding whatever bodyId might already be in the prototype.
    void addBodyFixedDecoration(MobilizedBodyId bodyNum, 
                                const Transform& X_GD, 
                                const DecorativeGeometry&);

    /// Add a line which is always present, but straddles stations on two different bodies.
    /// The passed-in line is used as a prototype, although its endpoints are ignored.
    void addRubberBandLine(MobilizedBodyId b1, const Vec3& station1, 
                           MobilizedBodyId b2, const Vec3& station2,
                           const DecorativeLine&);

    /// Show a supplied piece of geometry at the location of the system center of mass.
    /// Any transform stored with the supplied geometry is applied; any bodyId is
    /// ignored. This is an example of fixed geometry (i.e. its 3d representation doesn't
    /// change) but whose location varies on its body (in this case Ground).
    /// TODO: it should be oriented along the system's principal moments of inertia.
    void setSystemCenterOfMassMarker(const DecorativeGeometry&);



    ///////////////////////////////
    // MATTER SUBSYSTEM SERVICES //
    ///////////////////////////////

    /// @name Low level interface
    ///
    /// This group of methods extends the functionality of the underlying concrete
    /// MatterSubsystem implementation for convenience, but through inline implementations
    /// which introduce no performance cost.

    //@{


    /// This can be called at any time after construction. It sizes a set of
    /// force arrays (if necessary) and then sets them to zero. The concrete
    /// implementations of the "addIn" operators (see above) can then be used by
    /// the force subsystems to accumulate forces.
    void resetForces(Vector_<SpatialVec>& bodyForces,
                     Vector_<Vec3>&       particleForces,
                     Vector&              mobilityForces) const 
    {
        bodyForces.resize(getNBodies());         bodyForces.setToZero();
        particleForces.resize(getNParticles());  particleForces.setToZero();
        mobilityForces.resize(getNMobilities()); mobilityForces.setToZero();
    }

    // End of low level interface.
    //@}

    //////////////////////////////
    // CONCRETE CLASS INTERFACE //
    //////////////////////////////

    /// @name Interface to concrete implementation
    ///
    /// The MatterSubsystemRep (an abstract class) provides implementations underlying the MatterSubsystem
    /// wrapper methods below, typically as virtual methods to be implemented by derived concrete classes 
    /// (e.g. SimbodyMatterSubsystemRep). The wrappers defined below are in turn used
    /// to implement the friendlier APIs defined above.

        // TOPOLOGY STAGE (no state) //

    int getNBodies()      const;    // includes ground, also # mobilizers+1
    int getNParticles()   const;
    int getNMobilities()  const;
    int getNConstraints() const;    // i.e., Constraint definitions (each is multiple equations)

        // MODEL STAGE responses //

    /// Return the number of generalized coordinates (q) currently being used to model
    /// a body's Mobilizer. Typically this will be the same as the mobility (number
    /// of degrees of freedom) provided by the Mobilizer, but orientations are
    /// sometimes modeled with 4 coordinates (quaternions) for stability, even though they 
    /// require only 3 degrees of freedom.
    int getNMobilizerCoords(const State&, MobilizedBodyId) const; // 0-7

    /// Return the number of generalized speeds (u) being used to model a body's 
    /// mobility. This is always the same as the number of degrees of freedom
    /// provided by its mobilizer. This is also the number of generalized forces
    /// that can be applied directly to the mobilizer.
    int getNMobilizerSpeeds(const State&, MobilizedBodyId) const; // 0-6

    /// Obtain as a Vector the current values for all the mobilizer generalized coordinates (q) for
    /// a particular body. If you know the number of mobilities, it is more efficient
    /// use one of the fixed-sized methods, but here you don't need to know the
    /// number of coordinates in advance.
    /// @see getMobilizerCoord()
    /// @see getMobilizerCoordsAsVec2(), etc.
    Vector getMobilizerCoords(const State&, MobilizedBodyId) const;

    /// Obtain the current values for all the mobilizer generalized speeds (u) for
    /// a particular body. If you know the number of mobilities, it is more efficient
    /// use one of the fixed-sized methods, but here you don't need to know the
    /// number of speeds in advance.
    /// @see getMobilizerSpeed()
    /// @see getMobilizerSpeedsAsVec2(), etc.
    Vector getMobilizerSpeeds(const State&, MobilizedBodyId) const;

    // OBSOLETE
    Real getMobilizerQ(const State&, MobilizedBodyId, int coordIndex) const; ///< OBSOLETE
    Real getMobilizerU(const State&, MobilizedBodyId, int speedIndex) const; ///< OBSOLETE

    Real getOneMobilizerCoord       (const State&, MobilizedBodyId, int coordIndex) const;
    Real getOneMobilizerSpeed       (const State&, MobilizedBodyId, int speedIndex) const;

    /// Obtain the current value of the mobilizer generalized coordinate (q) for a body whose
    /// mobilizer has exactly one generalized coordinate (e.g., a torsion or sliding joint). This is a
    /// state variable and may be obtained at Stage::Model or above. This routine will throw
    /// an exception if the body's mobilizer does not have exactly one coordinate.
    Real getMobilizerCoord(const State&, MobilizedBodyId) const;
    /// Obtain mobilizer generalized coordinates for a mobilizer with exactly two generalized coordinates.
    const Vec2& getMobilizerCoordsAsVec2(const State&, MobilizedBodyId) const;
    /// Obtain mobilizer generalized coordinates for a mobilizer with exactly three generalized coordinates.
    const Vec3& getMobilizerCoordsAsVec3(const State&, MobilizedBodyId) const;
    /// Obtain mobilizer generalized coordinates for a mobilizer with exactly four generalized coordinates.
    const Vec4& getMobilizerCoordsAsVec4(const State&, MobilizedBodyId) const;
    /// Obtain mobilizer generalized coordinates for a mobilizer with exactly five generalized coordinates.
    const Vec5& getMobilizerCoordsAsVec5(const State&, MobilizedBodyId) const;
    /// Obtain mobilizer generalized coordinates for a mobilizer with exactly six generalized coordinates.
    const Vec6& getMobilizerCoordsAsVec6(const State&, MobilizedBodyId) const;
    /// Obtain mobilizer generalized coordinates for a mobilizer with exactly seven generalized coordinates.
    const Vec7& getMobilizerCoordsAsVec7(const State&, MobilizedBodyId) const;

    const Vector& getAllMobilizerCoords(const State&) const;

    /// Obtain the current value of the mobilizer generalized speed (u) for a body whose
    /// mobilizer has exactly one generalized speed. This is a state variable and may
    /// be obtained at Stage::Model or above. This routine will throw an exception
    /// if the body's mobilizer does not have exactly one generalized speed.
    Real getMobilizerSpeed(const State&, MobilizedBodyId) const;
    /// Obtain mobilizer generalized speeds for a mobilizer with exactly two generalized speeds.
    const Vec2& getMobilizerSpeedsAsVec2(const State&, MobilizedBodyId) const;
    /// Obtain mobilizer generalized speeds for a mobilizer with exactly three generalized speeds.
    const Vec3& getMobilizerSpeedsAsVec3(const State&, MobilizedBodyId) const;
    /// Obtain mobilizer generalized speeds for a mobilizer with exactly four generalized speeds.
    const Vec4& getMobilizerSpeedsAsVec4(const State&, MobilizedBodyId) const;
    /// Obtain mobilizer generalized speeds for a mobilizer with exactly five generalized speeds.
    const Vec5& getMobilizerSpeedsAsVec5(const State&, MobilizedBodyId) const;
    /// Obtain mobilizer generalized speeds for a mobilizer with exactly six generalized speeds.
    const Vec6& getMobilizerSpeedsAsVec6(const State&, MobilizedBodyId) const;

    const Vector& getAllMobilizerSpeeds(const State&) const;

    // Bodies

    // Particles

    // The generalized coordinates for a particle are always the three measure numbers
    // (x,y,z) of the particle's Ground-relative Cartesian location vector. The generalized
    // speeds are always the three corresponding measure numbers of the particle's
    // Ground-relative Cartesian velocity. The generalized applied forces are
    // always the three measure numbers of a Ground-relative force vector.
    const Vector_<Vec3>& getAllParticleLocations    (const State&) const;
    const Vector_<Vec3>& getAllParticleVelocities   (const State&) const;

    const Vec3& getParticleLocation(const State& s, ParticleId p) const {
        return getAllParticleLocations(s)[p];
    }
    const Vec3& getParticleVelocity(const State& s, ParticleId p) const {
        return getAllParticleVelocities(s)[p];
    }

        // MODEL STAGE operators //
    // none

        // MODEL STAGE solvers //

    // Routines for directly setting the generalized coordinates, speeds, and
    // applied forces are "null" solvers in that they modify the state but don't do any
    // computation. These will always succeed if the mobilizer has the 
    // right number of coordinates or speeds for the method being called.
    // An exception will be thrown if there is a mismatch. 
    // 
    // You can call these routines in Stage::Model or above; they set state
    // variables without looking at any coordinates or speeds. Setting a generalized 
    // coordinate (q) will invalidate Stage::Position and above; setting
    // a generalized speed (u) will invalidate Stage::Velocity and above, 
    // setting a generalized applied force (f) will invalidate Stage::Acceleration
    // and above.

    // The concrete MatterSubsystem must provide these routines.
    Vector& updAllMobilizerCoords       (State&) const;
    Vector& updAllMobilizerSpeeds       (State&) const;


    void setMobilizerQ(State&, MobilizedBodyId, int coordIndex, Real qValue) const; ///< OBSOLETE
    void setMobilizerU(State&, MobilizedBodyId, int speedIndex, Real uValue) const; ///< OBSOLETE

    void setOneMobilizerCoord       (State&, MobilizedBodyId, int coordIndex, Real q) const;
    void setOneMobilizerSpeed       (State&, MobilizedBodyId, int speedIndex, Real u) const;

    void setMobilizerCoords       (State&, MobilizedBodyId, const Vector& q) const;
    void setMobilizerSpeeds       (State&, MobilizedBodyId, const Vector& u) const;

    void setMobilizerCoord       (State&, MobilizedBodyId, Real        q) const;
    void setMobilizerCoordsAsVec2(State&, MobilizedBodyId, const Vec2& q) const;
    void setMobilizerCoordsAsVec3(State&, MobilizedBodyId, const Vec3& q) const;
    void setMobilizerCoordsAsVec4(State&, MobilizedBodyId, const Vec4& q) const;
    void setMobilizerCoordsAsVec5(State&, MobilizedBodyId, const Vec5& q) const;
    void setMobilizerCoordsAsVec6(State&, MobilizedBodyId, const Vec6& q) const;
    void setMobilizerCoordsAsVec7(State&, MobilizedBodyId, const Vec7& q) const;

    void setAllMobilizerCoords(State&, const Vector& q) const;

    void setMobilizerSpeed       (State&, MobilizedBodyId, Real        u) const;
    void setMobilizerSpeedsAsVec2(State&, MobilizedBodyId, const Vec2& u) const;
    void setMobilizerSpeedsAsVec3(State&, MobilizedBodyId, const Vec3& u) const;
    void setMobilizerSpeedsAsVec4(State&, MobilizedBodyId, const Vec4& u) const;
    void setMobilizerSpeedsAsVec5(State&, MobilizedBodyId, const Vec5& u) const;
    void setMobilizerSpeedsAsVec6(State&, MobilizedBodyId, const Vec6& u) const;

    void setAllMobilizerSpeeds(State&, const Vector& u) const;


        // PARTICLES

    Vector&         updAllParticleMasses(State& s) const;

    void setAllParticleMasses(State& s, const Vector& masses) const {
        updAllParticleMasses(s) = masses;
    }


    // Note that particle generalized coordinates, speeds, and applied forces
    // are defined to be the particle Cartesian locations, velocities, and
    // applied force vectors, so can be set directly at Stage::Model or higher.

    // These are the only routines that must be provided by the concrete MatterSubsystem.
    Vector_<Vec3>& updAllParticleLocations(State&)     const;
    Vector_<Vec3>& updAllParticleVelocities(State&)    const;

    // The following inline routines are provided by the generic MatterSubsystem class
    // for convenience.

    Vec3& updParticleLocation(State& s, ParticleId p) const {
        return updAllParticleLocations(s)[p];
    }
    Vec3& updParticleVelocity(State& s, ParticleId p) const {
        return updAllParticleVelocities(s)[p];
    }

    void setParticleLocation(State& s, ParticleId p, const Vec3& r) const {
        updAllParticleLocations(s)[p] = r;
    }
    void setParticleVelocity(State& s, ParticleId p, const Vec3& v) const {
        updAllParticleVelocities(s)[p] = v;
    }

    void setAllParticleLocations(State& s, const Vector_<Vec3>& r) const {
        updAllParticleLocations(s) = r;
    }
    void setAllParticleVelocities(State& s, const Vector_<Vec3>& v) const {
        updAllParticleVelocities(s) = v;
    }

        // INSTANCE STAGE responses //

    /// Return the mass, center of mass location measured from the body origin, and
    /// inertia about the body origin. Center of mass and inertia are expressed in
    /// the body frame. Individual quantities can be extracted from the MassProperties
    /// object via getMass(), getMassCenter(), and getInertia() methods.
    //const MassProperties& getBodyMassProperties(const State&, MobilizedBodyId) const;

    /// TODO: not implemented yet; particles must be treated as rigid bodies for now.
    const Vector& getAllParticleMasses(const State&) const;

    /// Return the body-fixed frame M associated with the body's unique mobilizer.
   // const Transform&  getMobilizerFrame(const State&, MobilizedBodyId) const;

    /// Given body B whose mobilizer connects it to its unique parent body P,
    /// return the P-fixed frame Mb associated with body B's mobilizer. That is, B's
    /// mobilizer connects the parent's frame Mb with body B's frame M. Here
    /// we return the fixed transform X_PMb which gives the location and orientation
    /// of frame Mb in P's body frame.
    //const Transform&  getMobilizerFrameOnParent(const State&, MobilizedBodyId) const;

        // INSTANCE STAGE operators //
    // none

        // INSTANCE STAGE solvers //
    // none

        // TIME STAGE responses
    // none

        // TIME STAGE operators
    // none

        // TIME STAGE solvers


        // POSITION STAGE responses //

    /// Extract from the state cache the already-calculated spatial configuration of
    /// body B's body frame, measured with respect to the ground frame and expressed
    /// in the ground frame. That is, we return the location of the body frame's
    /// origin, and the orientation of its x, y, and z axes, as the transform X_GB.
    /// This response is available at Position stage.
    //const Transform& getBodyTransform(const State&, MobilizedBodyId) const;

    /// This is available at Stage::Position. These are *absolute* constraint
    /// violations qerr=g(t,q), that is, they are unweighted.
    const Vector& getQConstraintErrors(const State&) const;

    /// This is the weighted norm of the errors returned by getQConstraintErrors(),
    /// available whenever this subsystem has been realized to Stage::Position.
    /// This is the scalar quantity that we need to keep below "tol"
    /// during integration.
    Real calcQConstraintNorm(const State&) const;

        // POSITION STAGE operators //


    /// Apply a force to a point on a body (a station). Provide the
    /// station in the body frame, force in the ground frame. Must
    /// be realized to Position stage prior to call.
    void addInStationForce(const State&, MobilizedBodyId bodyB, const Vec3& stationOnB, 
                           const Vec3& forceInG, Vector_<SpatialVec>& bodyForces) const;

    /// Apply a torque to a body. Provide the torque vector in the
    /// ground frame.
    void addInBodyTorque(const State&, MobilizedBodyId, const Vec3& torqueInG, 
                         Vector_<SpatialVec>& bodyForces) const;

    /// Apply a scalar joint force or torque to an axis of the
    /// indicated body's mobilizer.
    void addInMobilityForce(const State&, MobilizedBodyId, int axis, Real f,
                            Vector& mobilityForces) const;

        // POSITION STAGE solvers //

    /// This is a solver you can call after the State has been realized
    /// to stage Position. It will project the Q constraints
    /// along the error norm so that getQConstraintNorm() <= tol, and will
    /// project out the corresponding component of y_err so that y_err's Q norm
    /// is reduced. Returns true if it does anything at all to State or y_err.
    bool projectQConstraints(State&, Vector& y_err, Real tol, Real targetTol) const;

        // VELOCITY STAGE responses //

    /// Extract from the state cache the already-calculated spatial velocity of
    /// body B's body frame, measured with respect to the ground frame and expressed
    /// in the ground frame. That is, we return the linear velocity v_GB of the body
    /// frame's origin, and the body's angular velocity w_GB as the spatial velocity
    /// vector V_GB = {w_GB, v_GB}. This response is available at Velocity stage.
    //const SpatialVec& getBodyVelocity(const State&, MobilizedBodyId bodyB) const;

    /// This is available at Stage::Velocity. These are *absolute* constraint
    /// violations verr=v(t,q,u), that is, they are unweighted.
    const Vector& getUConstraintErrors(const State&) const;

    /// This is the weighted norm of the errors returned by getUConstraintErrors().
    /// That is, this is the scalar quantity that we need to keep below "tol"
    /// during integration.
    Real calcUConstraintNorm(const State&) const;

        // VELOCITY STAGE operators //
    // none

        // VELOCITY STAGE solvers //

    /// This is a solver you can call after the State has been realized
    /// to stage Velocity. It will project the U constraints
    /// along the error norm so that getUConstraintNorm() <= tol, and will
    /// project out the corresponding component of y_err so that y_err's U norm
    /// is reduced.
    bool projectUConstraints(State&, Vector& y_err, Real tol, Real targetTol) const;

        // DYNAMICS STAGE responses //
    // none

        // DYNAMICS STAGE operators //
    // none

        // DYNAMICS STAGE solvers //
    // none

        // ACCELERATION STAGE responses //

    /// Extract from the state cache the already-calculated spatial acceleration of
    /// body B's body frame, measured with respect to the ground frame and expressed
    /// in the ground frame. That is, we return the linear acceleration a_GB of the body
    /// frame's origin, and the body's angular acceleration alpha_GB as the spatial acceleration
    /// vector A_GB = {alpha_GB, a_GB}. This response is available at Acceleration stage.
    //const SpatialVec& getBodyAcceleration(const State&, MobilizedBodyId bodyB) const;

    const Vector_<Vec3>& getAllParticleAccelerations(const State&) const;

    const Vec3& getParticleAcceleration(const State& s, ParticleId p) const {
        return getAllParticleAccelerations(s)[p];
    }
    /// This is available at Stage::Acceleration. These are *absolute* constraint
    /// violations aerr = A udot - b, that is, they are unweighted.
    const Vector& getUDotConstraintErrors(const State&) const;

    /// This is the weighted norm of the errors returned by getUDotConstraintErrors().
    Real calcUDotConstraintNorm(const State&) const;

    // End of concrete class interface.
    //@}


        // BOOKKEEPING //

    /// @name Bookkeeping
    /// For internal use only.
    //@{
    /// Default constructor does nothing; parent class Subsystem's default
    /// constructor will have been called though and may do something.
    MatterSubsystem() { }
    /// Return a writable reference to the SubsystemRep, downcast to a MatterSubsystemRep.
    class MatterSubsystemRep& updRep();
    /// Return a read-only reference to the SubsystemRep, downcast to a MatterSubsystemRep.
    const MatterSubsystemRep& getRep() const;
    /// Generate the standard set of routines for a SimTK PIMPL handle class.
    SimTK_PIMPL_DOWNCAST(MatterSubsystem, Subsystem);
    //@}
};

} // namespace SimTK

#endif // SimTK_MATTER_SUBSYSTEM_H_
