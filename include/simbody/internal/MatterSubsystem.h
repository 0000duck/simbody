#ifndef SimTK_MATTER_SUBSYSTEM_H_
#define SimTK_MATTER_SUBSYSTEM_H_

/* Portions copyright (c) 2005-6 Stanford University and Michael Sherman.
 * Contributors: Paul Mitiguy
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including 
 * without limitation the rights to use, copy, modify, merge, publish, 
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include "SimTKcommon.h"
#include "simbody/internal/common.h"
#include "simbody/internal/Subsystem.h"

namespace SimTK {

/**
 * The still-abstract parent of all MatterSubsystems (such as the
 * one generated by Simbody). This is derived from Subsystem.
 *
 * The MatterSubsystem class implements a friendlier API on top of
 * the efficient, minimalist interface required of concrete MatterSubsystem
 * implementation classes (such as SimbodyMatterSubsystem). In many cases
 * these are inline implementations, but some performance
 * tradeoffs are made in this API in the interest of beauty and simplicity. These
 * are expected to be insignificant in most applications but if (after measurement!)
 * you determine that these are a bottleneck you are always welcome to call
 * directly into the part of the interface which is directly implemented by
 * the concrete class. The concrete class methods are defined after the 
 * friendly one below.
 *
 * This API was designed by Paul Mitiguy and Michael Sherman to address
 * the anticipated needs of Paul's BMI 215 students at Stanford. However,
 * we expect it will be useful for many other purposes.
 */
class SimTK_SIMBODY_EXPORT MatterSubsystem : public Subsystem {
public:
    ///////////////////////////////
    // PAUL'S FRIENDLY INTERFACE //
    ///////////////////////////////

    /// @name High level interface
    /// In the API below, we consistently use "body B" as the "object" or "main"
    /// body with which we are concerned. Often there will be an additional body mentioned
    /// in the argument list as a target for some conversion. That "auxiliary" body will
    /// be called "body A". The Ground body (BodyId(0), predefined as GroundId) is
    /// abbreviated "G".
    ///
    /// We use OF to mean "the origin of frame F", CB is "the mass center of body B".
    /// R_AF is the rotation matrix giving frame F's
    /// orientation in frame A, such that a vector v expressed in F is reexpressed in
    /// A by v_A = R_AF * v_F. X_AF is the spatial transform giving frame F's origin
    /// location and orientation in frame A, such that a point P whose location is
    /// measured from F's origin OF and expressed in F by vector r_OF_P is remeasured from
    /// frame A's origin and reexpressed in A via r_OA_P = X_AF * r_OF_P. 

    //@{

        // MASS PROPERTIES //

    /// Return the mass properties of body B, measured in the B frame, but expressed
    /// in body A. That is, return the mass, mass center location r_OB_CB, and
    /// the inertia about the body origin OB, expressed in A. If body A is the
    /// same body as body B, then the mass properties can be obtained after realizing
    /// only to the Instance stage, otherwise the state must have been realized
    /// to Position stage.
    ///
    /// If inBodyA==GroundId, the returned mass properties are equivalent to
    /// the Spatial Inertia matrix as used in the
    /// Spatial Operator Algebra formulation (that is, the local body mass
    /// properties but expressed in Ground). You can pull out the
    /// individual elements of MassProperties m with m.getMass(), 
    /// m.getMassCenter() and m.getInertia(). You can get them as
    /// a Spatial Inertia Matrix (2x2 x Mat33) with m.toSpatialMat()
    /// or as a 6x6 matrix with m.toMat66().
    ///
    /// @par Required stage
    ///   \c Stage::Instance, if \a inBodyA ==\a objectBodyB
    /// \n\c Stage::Position otherwise.
    MassProperties calcBodyMassPropertiesInBody(const State& s, 
                                                BodyId objectBodyB,
                                                BodyId inBodyA) const
    {
        const MassProperties& mp = getBodyMassProperties(s, objectBodyB);
        if (inBodyA == objectBodyB) 
            return mp;

        // must be at Stage >= Position
        Rotation R_BA = ~getBodyRotation(s,objectBodyB);  // R_BG (assume A==G)
        if (inBodyA != GroundId)
            R_BA *= getBodyRotation(s,inBodyA); // R_BA = R_BG*R_GA
        return mp.reexpress(R_BA); // i.e., reexpress from B to A
    }

    /**
     * Return the mass properties of body B, measured from and about
     * the B frame origin, but expressed in Ground and then returned
     * as a Spatial Inertia Matrix. The mass properties are arranged
     * in the SpatialMat like this:                  @verbatim
         M=[      I_OB      crossMat(m*CB) ]
           [ ~crossMat(m*CB)   diag(m)     ]         @endverbatim
     *  where I_OB is the inertia taken about the B frame origin OB,
     *  and CB is the vector r_OB_CB from B's origin to its mass center.
     * 
     *  @par Required stage
     *    \c Stage::Topology, if \a objectBodyB == \c GroundId
     *  \n\c Stage::Position otherwise.
     */
    SpatialMat calcBodySpatialInertiaMatrixInGround(const State& s,
                                                    BodyId objectBodyB) const
    {
        const MassProperties& mp   = getBodyMassProperties(s, objectBodyB);
        const Rotation&       R_GB = getBodyRotation(s,objectBodyB);
         // re-express in Ground without shifting, convert to spatial mat.
        return mp.reexpress(~R_GB).toSpatialMat();
    }

    /// Calculate the location of body B's mass center, measured from the origin 
    /// of body A, and expressed in the A frame.
    ///
    /// @par Required stage
    ///   \c Stage::Instance, if \a inBodyA == \a objectBodyB
    /// \n\c Stage::Position otherwise.
    Vec3 calcBodyMassCenterLocationInBody(const State& s, 
                                          BodyId      objectBodyB,
                                          BodyId      inBodyA) const
    {
        const Vec3& r_OB_CB = getBodyMassCenterStation(s,objectBodyB);
        if (inBodyA==GroundId) return locateBodyPointOnGround(s, objectBodyB, r_OB_CB);
        return locateBodyPointOnBody(s, objectBodyB, r_OB_CB, inBodyA);
    }

    /// Return the central inertia for body B, that is, the inertia taken about
    /// body B's mass center CB, and expressed in B.
    ///
    /// @par Required stage
    ///   \c Stage::Instance
    Inertia calcBodyCentralInertia(const State& s, 
                                   BodyId objectBodyB) const
    {
        return getBodyMassProperties(s, objectBodyB).calcCentralInertia();
    }

    /// Return the inertia of body B, taken about an arbitrary point PA of body A,
    /// and expressed in body A.
    /// TODO: this needs testing!
    Inertia calcBodyInertiaAboutBodyPoint(const State& s, 
                                          BodyId      objectBodyB, 
                                          BodyId      inBodyA, 
                                          const Vec3& aboutLocationOnBodyA) const
    {
        // get B's mass props MB, measured about OB, exp. in B
        const MassProperties& MB_OB_B = getBodyMassProperties(s,objectBodyB);

        // Calculate the vector from the body B origin (current "about" point) to the new "about" point PA,
        // expressed in B.
        const Vec3 r_OB_PA = calcBodyPointLocationInBody(s, inBodyA, aboutLocationOnBodyA, objectBodyB);

        // Now shift the "about" point for body B's inertia IB to PA, but still expressed in B.
        const Inertia IB_PA_B = MB_OB_B.calcShiftedInertia(r_OB_PA);
        
        // Finally reexpress the inertia in the A frame.
        const Rotation R_BA    = calcBodyRotationFromBody(s, inBodyA, objectBodyB);
        const Inertia  IB_PA_A = IB_PA_B.reexpress(R_BA);
        return IB_PA_A;
    }


    /// Return total system mass, mass center location measured from the Ground origin,
    /// and system inertia taken about the Ground origin, expressed in Ground.
    MassProperties calcSystemMassPropertiesInGround(const State& s) const;

    /// Return the system inertia matrix taken about the system center of mass,
    /// expressed in Ground.
    Inertia calcSystemCentralInertiaInGround(const State& s) const;

    /// Return the location r_OG_C of the system mass center C, measured from the ground
    /// origin OG, and expressed in Ground. 
    Vec3 calcSystemMassCenterLocationInGround(const State& s) const;

    /// Return the velocity V_G_C = d/dt r_OG_C of the system mass center C in the Ground frame G,
    /// expressed in G.
    Vec3 calcSystemMassCenterVelocityInGround(const State& s) const;

    /// Return the acceleration A_G_C = d^2/dt^2 r_OG_C of the system mass center C in
    /// the Ground frame G, expressed in G.
    Vec3 calcSystemMassCenterAccelerationInGround(const State& s) const;

        // POSITION //

    /// Return X_AB, the spatial transform to body B's frame from body A's frame.
    Transform calcBodyTransformFromBody(const State& s, 
                                        BodyId objectBodyB, 
                                        BodyId fromBodyA) const
    {
        const Transform& X_GB = getBodyTransform(s,objectBodyB);
        if (fromBodyA == GroundId) return X_GB;
        const Transform& X_GA = getBodyTransform(s,fromBodyA);
        return ~X_GA*X_GB;
    }

    /// Return R_AB, the rotation matrix to body B's x,y,z axes from body A's x,y,z axes.
    Rotation calcBodyRotationFromBody(const State& s, 
                                      BodyId objectBodyB, 
                                      BodyId fromBodyA) const
    {
        if (fromBodyA==objectBodyB) return Rotation();  // Identity rotation; no access to State

        if      (fromBodyA==GroundId)   return  getBodyRotation(s,objectBodyB); // R_GB
        else if (objectBodyB==GroundId) return ~getBodyRotation(s,fromBodyA);   // R_AG (=~R_GA)
        else                            return ~getBodyRotation(s,fromBodyA)    // R_AB=R_AG*R_GB
                                              * getBodyRotation(s,objectBodyB);
    }

    /// Return r_OA_OB, the location of body B's origin OB, measured from body A's
    /// origin OA, expressed in body A.
    Vec3 calcBodyOriginLocationInBody(const State& s,
                                      BodyId objectBodyB, 
                                      BodyId inBodyA) const
    {
        if (inBodyA==objectBodyB) return Vec3(0);

        const Vec3& r_OG_OB = getBodyOriginLocation(s, objectBodyB); // from G origin, exp. in G
        if (inBodyA == GroundId) return r_OG_OB;
        else                     return locateGroundPointOnBody(s, r_OG_OB, inBodyA);
    }

    /// Given a vector r_OB_P measured from body B's origin to a point P on body B, expressed in body B,
    /// return the vector r_OA_P measured from body A's origin to point P, expressed in body A.
    Vec3 calcBodyPointLocationInBody(const State& s,
                                     BodyId       onBodyB,
                                     const Vec3&  locationOnBodyB, 
                                     BodyId       inBodyA) const
    {
        if      (onBodyB==inBodyA)  return locationOnBodyB;
        else if (inBodyA==GroundId) return locateBodyPointOnGround(s,onBodyB,locationOnBodyB);
        else if (onBodyB==GroundId) return locateGroundPointOnBody(s,locationOnBodyB,inBodyA);
        else                        return locateBodyPointOnBody(s, onBodyB, locationOnBodyB, inBodyA);
    }

    /// Given a vector v_B expressed in body B, return v_A, that same vector reexpressed in body A.
    Vec3 calcBodyVectorInBody(const State& s, 
                              BodyId       onBodyB, 
                              const Vec3&  vectorOnBodyB, 
                              BodyId       inBodyA) const
    {
        if      (onBodyB==inBodyA)  return vectorOnBodyB;
        else if (inBodyA==GroundId) return expressBodyVectorInGround(s,onBodyB,vectorOnBodyB);
        else if (onBodyB==GroundId) return expressGroundVectorInBody(s,vectorOnBodyB,inBodyA);
        else                        return expressBodyVectorInBody(s, onBodyB, vectorOnBodyB, inBodyA);
    }

        // VELOCITY //

    /// Return the angular and linear velocity of body B's frame in body A's frame, expressed in body A,
    /// and arranged as a SpatialVec.
    SpatialVec calcBodySpatialVelocityInBody(const State& s, 
                                             BodyId objectBodyB, 
                                             BodyId inBodyA) const
    {
        const SpatialVec& V_GB = getBodyVelocity(s,objectBodyB);
        if (inBodyA == GroundId) return V_GB;

        // Body A is not Ground so we'll have to compute relative velocity.

        const SpatialVec& V_GA   = getBodyVelocity(s,inBodyA);
        const Vec3        w_AB_G = V_GB[0]-V_GA[0]; // angular velocity of B in A, exp in G

        // Angular velocity was easy, but for linear velocity we have to add in an wXr term.
        const Transform&  X_GB      = getBodyTransform(s,objectBodyB);
        const Transform&  X_GA      = getBodyTransform(s,inBodyA);
        const Vec3        r_OA_OB_G = X_GB.T() - X_GA.T(); // vector from OA to OB, exp in G

        const Vec3 v_AB_G = (V_GB[1]-V_GA[1]) + w_AB_G % r_OA_OB_G; // linear velocity of OB in A, exp in G

        // We're done, but the answer is expressed in Ground. Reexpress in A and return.
        const Rotation& R_GA = X_GA.R();
        return SpatialVec(~R_GA*w_AB_G, ~R_GA*v_AB_G);
    }

    /// Return the angular velocity w_AB of body B's frame in body A's frame, expressed in body A.
    Vec3 calcBodyAngularVelocityInBody(const State& s, 
                                       BodyId objectBodyB, 
                                       BodyId inBodyA) const 
    {
        const SpatialVec& V_GB = getBodyVelocity(s,objectBodyB);
        if (inBodyA == GroundId) return V_GB[0];

        // Body A is not Ground so we'll have to compute relative angular velocity.
        const SpatialVec& V_GA   = getBodyVelocity(s,inBodyA);
        const Vec3        w_AB_G = V_GB[0]-V_GA[0]; // angular velocity of B in A, exp in G

        // Now reexpress in A.
        const Rotation& R_GA = getBodyRotation(s,inBodyA);
        return ~R_GA*w_AB_G;
    }

    /// Return the velocity of body B's origin point in body A's frame, expressed in body A.
    Vec3 calcBodyOriginVelocityInBody(const State& s,
                                      BodyId objectBodyB,
                                      BodyId inBodyA) const
    {
        // Doesn't save much to special case this one.
        return calcBodySpatialVelocityInBody(s,objectBodyB,inBodyA)[1];
    }

    /// Return the velocity of a point P fixed on body B, in body A's frame, expressed in body A.
    Vec3 calcBodyFixedPointVelocityInBody(const State& s, 
                                          BodyId      objectBodyB, 
                                          const Vec3& locationOnBodyB, 
                                          BodyId      inBodyA) const;

    /// Return the velocity of a point P moving on body B, in body A's frame, expressed in body A.
    Vec3 calcBodyMovingPointVelocityInBody(const State& s,
                                           BodyId      objectBodyB, 
                                           const Vec3& locationOnBodyB, 
                                           const Vec3& velocityOnBodyB,
                                           BodyId      inBodyA) const;

        // ACCELERATION //

    /// Return the angular and linear acceleration of body B's frame in body A's frame, expressed in body A,
    /// and arranged as a SpatialVec.
    SpatialVec calcBodySpatialAccelerationInBody(const State& s, 
                                                 BodyId objectBodyB, 
                                                 BodyId inBodyA) const;

    /// Return the angular acceleration of body B's frame in body A's frame, expressed in body A.
    Vec3 calcBodyAngularAccelerationInBody(const State& s, 
                                           BodyId objectBodyB, 
                                           BodyId inBodyA) const;

    /// Return the acceleration of body B's origin point in body A's frame, expressed in body A.
    Vec3 calcBodyOriginAccelerationInBody(const State& s, 
                                          BodyId objectBodyB, 
                                          BodyId inBodyA) const;

    /// Return the acceleration of a point P fixed on body B, in body A's frame, expressed in body A.
    Vec3 calcBodyFixedPointAccelerationInBody(const State& s, 
                                              BodyId      objectBodyB, 
                                              const Vec3& locationOnBodyB, 
                                              BodyId      inBodyA) const;

    /// Return the velocity of a point P moving (and possibly accelerating) on body B,
    /// in body A's frame, expressed in body A.
    Vec3 calcBodyMovingPointAccelerationInBody(const State& s, 
                                               BodyId       objectBodyB, 
                                               const Vec3&  locationOnBodyB, 
                                               const Vec3&  velocityOnBodyB, 
                                               const Vec3&  accelerationOnBodyB,
                                               BodyId       inBodyA) const;

        // SCALAR DISTANCE //

    /// Calculate the distance to a point PB on body B from a point PA on body A.
    /// We are given the location vectors (stations) r_OB_PB and r_OA_PA, expressed in
    /// their respective frames. We return |r_OA_OB|.
    Real calcPointToPointDistance(const State& s,
                                  BodyId       bodyB,
                                  const Vec3&  locationOnBodyB,
                                  BodyId       bodyA,
                                  const Vec3&  locationOnBodyA) const;

    /// Calculate the time rate of change of distance from a fixed point PB on body B to a fixed point
    /// PA on body A. We are given the location vectors r_OB_PB and r_OA_PA, expressed in their
    /// respective frames. We return d/dt |r_OA_OB|, under the assumption that the time derivatives
    /// of the two given vectors in their own frames is zero.
    Real calcFixedPointToPointDistanceTimeDerivative(const State& s,
                                                     BodyId       bodyB,
                                                     const Vec3&  locationOnBodyB,
                                                     BodyId       bodyA,
                                                     const Vec3&  locationOnBodyA) const;


    /// Calculate the time rate of change of distance from a moving point PB on body B to a moving point
    /// PA on body A. We are given the location vectors r_OB_PB and r_OA_PA, and the velocities of
    /// PB in B and PA in A, all expressed in their respective frames. We return d/dt |r_OA_OB|,
    /// taking into account the time derivatives of the locations in their local frames, as well
    /// as the relative velocities of the bodies.
    Real calcMovingPointToPointDistanceTimeDerivative(const State& s,
                                                      BodyId       bodyB,
                                                      const Vec3&  locationOnBodyB,
                                                      const Vec3&  velocityOnBodyB,
                                                      BodyId       bodyA,
                                                      const Vec3&  locationOnBodyA,
                                                      const Vec3&  velocityOnBodyA) const;

    /// Calculate the second time derivative of distance from a fixed point PB on body B to a fixed point
    /// PA on body A. We are given the location vectors (stations) r_OB_PB and r_OA_PA, expressed in their
    /// respective frames. We return d^2/dt^2 |r_OA_OB|, under the assumption that the time derivatives
    /// of the two given vectors in their own frames is zero.
    Real calcFixedPointToPointDistance2ndTimeDerivative(const State& s,
                                                        BodyId       bodyB,
                                                        const Vec3&  locationOnBodyB,
                                                        BodyId       bodyA,
                                                        const Vec3&  locationOnBodyA) const;

    /// Calculate the second time derivative of distance from a moving point PB on body B to a moving point
    /// PA on body A. We are given the location vectors r_OB_PB and r_OA_PA, and the velocities and
    /// accelerations of PB in B and PA in A, all expressed in their respective frames. We return
    /// d^2/dt^2 |r_OA_OB|, taking into account the time derivatives of the locations in their
    /// local frames, as well as the relative velocities and accelerations of the bodies.
    Real calcMovingPointToPointDistance2ndTimeDerivative(const State& s,
                                                         BodyId       bodyB,
                                                         const Vec3&  locationOnBodyB,
                                                         const Vec3&  velocityOnBodyB,
                                                         const Vec3&  accelerationOnBodyB,
                                                         BodyId       bodyA,
                                                         const Vec3&  locationOnBodyA,
                                                         const Vec3&  velocityOnBodyA,
                                                         const Vec3&  accelerationOnBodyA) const;

    // End of high-level interface.
    //@}

    ///////////////////////////////
    // MATTER SUBSYSTEM SERVICES //
    ///////////////////////////////

    /// @name Low level interface
    ///
    /// This group of methods extends the functionality of the underlying concrete
    /// MatterSubsystem implementation for convenience, but through inline implementations
    /// which introduce no performance cost.

    //@{

    /// Return the mass of a given body. Callable at Instance Stage or higher.
    Real getBodyMass(const State& s, BodyId bodyB) const {
        return getBodyMassProperties(s,bodyB).getMass();
    }

    /// Return a body's center of mass station (i.e., the vector fixed in the body,
    /// going from body origin to body mass center, expressed in the body frame.)
    /// Callable at Instance Stage or higher.
    const Vec3& getBodyMassCenterStation(const State& s, BodyId bodyB) const {
        return getBodyMassProperties(s,bodyB).getMassCenter();
    }

    /// Return a body's inertia matrix, taken about the body origin and 
    /// expressed in the body frame.
    /// Callable at Instance Stage or higher.
    const Inertia& getBodyInertiaAboutBodyOrigin(const State& s, BodyId bodyB) const {
        return getBodyMassProperties(s,bodyB).getInertia();
    }

    /// Extract from the state cache the already-calculated spatial orientation
    /// of body B's body frame x, y, and z axes expressed in the ground frame,
    /// as the rotation matrix R_GB. This response is available at Position stage.
    const Rotation& getBodyRotation(const State& s, BodyId bodyB) const {
        return getBodyTransform(s,bodyB).R();
    }
    /// Extract from the state cache the already-calculated spatial location
    /// of body B's body frame origin OB, measured from the ground origin and
    /// expressed in the ground frame, as the translation vector r_OG_OB.
    /// This response is available at Position stage.
    const Vec3& getBodyOriginLocation(const State& s, BodyId bodyB) const {
        return getBodyTransform(s,bodyB).T();
    }

    /// Extract from the state cache the already-calculated inertial angular
    /// velocity vector w_GB of body B, measured with respect to the ground frame
    /// and expressed in the ground frame. This response is available at Velocity stage.
    const Vec3& getBodyAngularVelocity(const State& s, BodyId bodyB) const {
        return getBodyVelocity(s,bodyB)[0]; 
    }
    /// Extract from the state cache the already-calculated inertial linear
    /// velocity vector v_GB of body B, measured with respect to the ground frame
    /// and expressed in the ground frame. This response is available at Velocity stage.
    const Vec3& getBodyLinearVelocity(const State& s, BodyId bodyB) const {
        return getBodyVelocity(s,bodyB)[1];
    }

    /// Return the Cartesian (ground) location of a station fixed on body B. That is
    /// we return locationOnG = X_GB * locationOnB which means the result is measured from
    /// the ground origin and expressed in ground. Cost is 18 flops. This operator is
    /// available at Position stage.
    Vec3 locateBodyPointOnGround(const State& s, BodyId onBodyB, const Vec3& locationOnB) const {
        return getBodyTransform(s,onBodyB) * locationOnB;
    }

    /// Return the station fixed on body B that is coincident with the given Ground location.
    /// That is we return locationOnB = X_BG * locationOnG, which means the result is measured
    /// from the body origin OB and expressed in the body frame. Cost is 18 flops. This operator
    /// is available at Position stage or higher.
    Vec3 locateGroundPointOnBody(const State& s, const Vec3& locationOnG, BodyId toBodyB) const {
        return ~getBodyTransform(s, toBodyB) * locationOnG;
    }

    /// Given a location on body B, return the location on body A which is at the same location
    /// in space. That is, we return locationOnA = X_AB * locationOnB, which means the result
    /// is measured from the body A origin and expressed in body A. Cost is 36 flops.
    /// This operator is available at Position stage or higher.
    /// Note: if you know that one of the bodies is Ground, use one of the routines above
    /// which is specialized for Ground to avoid half the work.
    Vec3 locateBodyPointOnBody(const State& s, BodyId onBodyB, const Vec3& locationOnB, 
                               BodyId toBodyA) const
    {
        return locateGroundPointOnBody(s, locateBodyPointOnGround(s,onBodyB,locationOnB),
                                       toBodyA);
    }

    /// Re-express a vector expressed in body B's frame into the same vector in G. That is,
    /// we return vectorInG = R_GB * vectorInB. Cost is 15 flops. 
    /// This operator is available at Position stage.
    Vec3 expressBodyVectorInGround(const State& s, BodyId bodyB, const Vec3& vectorInB) const {
        return getBodyRotation(s,bodyB)*vectorInB;
    }

    /// Re-express a vector expressed in Ground into the same vector expressed in body A. That is,
    /// we return vectorInA = R_AG * vectorInG. Cost is 15 flops. 
    /// This operator is available at Position stage.
    Vec3 expressGroundVectorInBody(const State& s, const Vec3& vectorInG, BodyId inBodyA) const {
        return ~getBodyRotation(s,inBodyA)*vectorInG;
    }

    /// Re-express a vector expressed in body B into the same vector expressed in body A.
    /// That is, we return vectorInA = R_AB * vectorInB. Cost is 30 flops.
    /// This operator is available at Position stage.
    /// Note: if you know one of the bodies is Ground, call one of the specialized methods
    /// above to save 15 flops.
    Vec3 expressBodyVectorInBody(const State& s, BodyId objectBodyB, const Vec3& vectorInB,
                                 BodyId inBodyA) const
    {
        return expressGroundVectorInBody(s, expressBodyVectorInGround(s,objectBodyB,vectorInB),
                                         inBodyA);
    }

    /// Given a station fixed on body B, return its inertial (Cartesian) velocity,
    /// that is, its velocity relative to the ground frame, expressed in the
    /// ground frame. Cost is 27 flops. This operator is available at Velocity stage.
    Vec3 calcStationVelocity(const State& s, BodyId bodyB, const Vec3& stationOnB) const {
        const SpatialVec& V_GB         = getBodyVelocity(s,bodyB);
        const Vec3        stationOnB_G = expressBodyVectorInGround(s,bodyB,stationOnB);
        return V_GB[1] + V_GB[0] % stationOnB_G; // v + w X r
    }

    /// Given a station fixed on body B, return its velocity relative to the body frame of
    /// body A, and expressed in body A's body frame. Cost is 54 flops.
    /// This operator is available at Velocity stage.
    /// TODO: UNTESTED!!
    /// TODO: maybe these between-body routines should return results in ground so that they
    /// can be easily combined. Easy to re-express vector afterwards.
    Vec3 calcStationVelocityInBody(const State& s, BodyId bodyB, const Vec3& stationOnB, BodyId bodyA) const {
        // If body B's origin were coincident with body A's, then Vdiff_AB would be the relative angular
        // and linear velocity of body B in body A, expressed in G. To get the point we're interested in,
        // we need the vector from body A's origin to stationB to account for the extra linear velocity
        // that will be created by moving away from the origin, due to the bodies' relative angular
        // velocity.
        const SpatialVec Vdiff_AB = getBodyVelocity(s,bodyB) - getBodyVelocity(s,bodyA); // 6

        // This is a vector from body A's origin to the point of interest, expressed in G.
        const Vec3 stationA_G = locateBodyPointOnGround(s,bodyB,stationOnB) - getBodyOriginLocation(s,bodyA); // 21
        const Vec3 v_AsB_G = Vdiff_AB[1] + Vdiff_AB[0] % stationA_G; // 12
        return ~getBodyRotation(s,bodyA) * v_AsB_G; // 15
    }

    /// This can be called at any time after construction. It sizes a set of
    /// force arrays (if necessary) and then sets them to zero. The concrete
    /// implementations of the "addIn" operators (see above) can then be used by
    /// the force subsystems to accumulate forces.
    void resetForces(Vector_<SpatialVec>& bodyForces,
                     Vector_<Vec3>&       particleForces,
                     Vector&              mobilityForces) const 
    {
        bodyForces.resize(getNBodies());         bodyForces.setToZero();
        particleForces.resize(getNParticles());  particleForces.setToZero();
        mobilityForces.resize(getNMobilities()); mobilityForces.setToZero();
    }

    // End of low level interface.
    //@}

    //////////////////////////////
    // CONCRETE CLASS INTERFACE //
    //////////////////////////////

    /// @name Interface to concrete implementation
    ///
    /// The MatterSubsystemRep (an abstract class) provides implementations underlying the MatterSubsystem
    /// wrapper methods below, typically as virtual methods to be implemented by derived concrete classes 
    /// (e.g. SimbodyMatterSubsystemRep). The wrappers defined below are in turn used
    /// to implement the friendlier APIs defined above.

        // TOPOLOGY STAGE (no state) //

    int getNBodies()      const;    // includes ground, also # mobilizers+1
    int getNParticles()   const;
    int getNMobilities()  const;
    int getNConstraints() const;    // i.e., Constraint definitions (each is multiple equations)

    BodyId        getParent  (BodyId) const;
    Array<BodyId> getChildren(BodyId) const;

        // MODEL STAGE responses //

    const Real& getMobilizerQ(const State&, BodyId, int mobilityIndex) const;
    const Real& getMobilizerU(const State&, BodyId, int mobilityIndex) const;

        // MODEL STAGE operators //
    // none

        // MODEL STAGE solvers //

    void setMobilizerQ(State&, BodyId, int mobilityIndex, const Real& mobilityValue) const;
    void setMobilizerU(State&, BodyId, int mobilityIndex, const Real& mobilityValue) const;

        // INSTANCE STAGE responses //

    /// Return the mass, center of mass location measured from the body origin, and
    /// inertia about the body origin. Center of mass and inertia are expressed in
    /// the body frame. Individual quantities can be extracted from the MassProperties
    /// object via getMass(), getMassCenter(), and getInertia() methods.
    const MassProperties& getBodyMassProperties(const State&, BodyId) const;

    /// TODO: not implemented yet; particles must be treated as rigid bodies for now.
    const Vector& getParticleMasses(const State&) const;

    /// Return the body-fixed frame M associated with the body's unique mobilizer.
    const Transform&  getMobilizerFrame(const State&, BodyId) const;

    /// Given body B whose mobilizer connects it to its unique parent body P,
    /// return the P-fixed frame Mb associated with body B's mobilizer. That is, B's
    /// mobilizer connects the parent's frame Mb with body B's frame M. Here
    /// we return the fixed transform X_PMb which gives the location and orientation
    /// of frame Mb in P's body frame.
    const Transform&  getMobilizerFrameOnParent(const State&, BodyId) const;

        // INSTANCE STAGE operators //
    // none

        // INSTANCE STAGE solvers //
    // none

        // TIME STAGE responses
    // none

        // TIME STAGE operators
    // none

        // TIME STAGE solvers

    /// This is a solver which sets the body's mobilizer transform as close
    /// as possible to the supplied Transform. The degree to which this is
    /// possible depends of course on the mobility provided by this body's
    /// mobilizer. However, no error will occur; on return the coordinates
    /// for this mobilizer will be as close as we can get them. Note: this
    /// has no effect on any coordinates except the q's for this mobilizer.
    /// You can call this solver at Stage::Time or higher (because there can
    /// be time-dependent constraints on position); it will
    /// leave you no higher than Stage::Time since it changes the configuration.
    void setMobilizerTransform(State&, BodyId, const Transform& X_MbM) const;

        // POSITION STAGE responses //

    /// TODO: not implemented yet. For now particles must be treated as rigid bodies.
    const Vector_<Vec3>& getParticleLocations(const State& s) const; 

    /// Extract from the state cache the already-calculated spatial configuration of
    /// body B's body frame, measured with respect to the ground frame and expressed
    /// in the ground frame. That is, we return the location of the body frame's
    /// origin, and the orientation of its x, y, and z axes, as the transform X_GB.
    /// This response is available at Position stage.
    const Transform& getBodyTransform(const State&, BodyId) const;

    /// At stage Position or higher, return the cross-mobilizer transform.
    /// This is X_MbM, the body's inboard mobilizer frame M measured and expressed in
    /// the parent body's corresponding outboard frame Mb.
    const Transform& getMobilizerTransform(const State&, BodyId) const;

    /// This is available at Stage::Position. These are *absolute* constraint
    /// violations qerr=g(t,q), that is, they are unweighted.
    const Vector& getQConstraintErrors(const State&) const;

    /// This is the weighted norm of the errors returned by getQConstraintErrors(),
    /// available whenever this subsystem has been realized to Stage::Position.
    /// This is the scalar quantity that we need to keep below "tol"
    /// during integration.
    Real calcQConstraintNorm(const State&) const;

        // POSITION STAGE operators //


    /// Apply a force to a point on a body (a station). Provide the
    /// station in the body frame, force in the ground frame. Must
    /// be realized to Position stage prior to call.
    void addInStationForce(const State&, BodyId bodyB, const Vec3& stationOnB, 
                           const Vec3& forceInG, Vector_<SpatialVec>& bodyForces) const;

    /// Apply a torque to a body. Provide the torque vector in the
    /// ground frame.
    void addInBodyTorque(const State&, BodyId, const Vec3& torqueInG, 
                         Vector_<SpatialVec>& bodyForces) const;

    /// Apply a scalar joint force or torque to an axis of the
    /// indicated body's mobilizer.
    void addInMobilityForce(const State&, BodyId, int axis, const Real& f,
                            Vector& mobilityForces) const;

        // POSITION STAGE solvers //

    /// This is a solver which sets the body's cross-mobilizer velocity as close
    /// as possible to the supplied angular and linear velocity. The degree to which this is
    /// possible depends of course on the mobility provided by this body's
    /// mobilizer, in its current configuration. However, no error will occur; on return
    /// the velocity coordinates (u's) for this mobilizer will be as close as we can get them.
    /// Note: this has no effect on any coordinates except the u's for this mobilizer.
    /// You can call this solver at Stage::Position or higher; it will
    /// leave you no higher than Stage::Position since it changes the velocities.
    void setMobilizerVelocity(State&, BodyId bodyB, const SpatialVec& V_MbM) const;

    /// This is a solver you can call after the State has been realized
    /// to stage Position. It will project the Q constraints
    /// along the error norm so that getQConstraintNorm() <= tol, and will
    /// project out the corresponding component of y_err so that y_err's Q norm
    /// is reduced. Returns true if it does anything at all to State or y_err.
    bool projectQConstraints(State&, Vector& y_err, Real tol, Real targetTol) const;

        // VELOCITY STAGE responses //

    /// Extract from the state cache the already-calculated spatial velocity of
    /// body B's body frame, measured with respect to the ground frame and expressed
    /// in the ground frame. That is, we return the linear velocity v_GB of the body
    /// frame's origin, and the body's angular velocity w_GB as the spatial velocity
    /// vector V_GB = {w_GB, v_GB}. This response is available at Velocity stage.
    const SpatialVec& getBodyVelocity(const State&, BodyId bodyB) const;

    /// At stage Velocity or higher, return the cross-mobilizer velocity.
    /// This is V_MbM, the relative velocity of the body's inboard mobilizer
    /// frame M in the parent body's corresponding outboard frame Mb, 
    /// measured and expressed in Mb. Note that this isn't the usual 
    /// spatial velocity since it isn't expressed in G.
    const SpatialVec& getMobilizerVelocity(const State&, BodyId bodyB) const;

    /// This is available at Stage::Velocity. These are *absolute* constraint
    /// violations verr=v(t,q,u), that is, they are unweighted.
    const Vector& getUConstraintErrors(const State&) const;

    /// This is the weighted norm of the errors returned by getUConstraintErrors().
    /// That is, this is the scalar quantity that we need to keep below "tol"
    /// during integration.
    Real calcUConstraintNorm(const State&) const;

        // VELOCITY STAGE operators //
    // none

        // VELOCITY STAGE solvers //

    /// This is a solver you can call after the State has been realized
    /// to stage Velocity. It will project the U constraints
    /// along the error norm so that getUConstraintNorm() <= tol, and will
    /// project out the corresponding component of y_err so that y_err's U norm
    /// is reduced.
    bool projectUConstraints(State&, Vector& y_err, Real tol, Real targetTol) const;

        // DYNAMICS STAGE responses //
    // none

        // DYNAMICS STAGE operators //
    // none

        // DYNAMICS STAGE solvers //
    // none

        // ACCELERATION STAGE responses //

    /// Extract from the state cache the already-calculated spatial acceleration of
    /// body B's body frame, measured with respect to the ground frame and expressed
    /// in the ground frame. That is, we return the linear acceleration a_GB of the body
    /// frame's origin, and the body's angular acceleration alpha_GB as the spatial acceleration
    /// vector A_GB = {alpha_GB, a_GB}. This response is available at Acceleration stage.
    const SpatialVec& getBodyAcceleration(const State&, BodyId bodyB) const;

    /// This is available at Stage::Acceleration. These are *absolute* constraint
    /// violations aerr = A udot - b, that is, they are unweighted.
    const Vector& getUDotConstraintErrors(const State&) const;

    /// This is the weighted norm of the errors returned by getUDotConstraintErrors().
    Real calcUDotConstraintNorm(const State&) const;

    // End of concrete class interface.
    //@}


        // BOOKKEEPING //

    /// @name Bookkeeping
    /// For internal use only.
    //@{
    /// Default constructor does nothing; parent class Subsystem's default
    /// constructor will have been called though and may do something.
    MatterSubsystem() { }
    /// Return a writable reference to the SubsystemRep, downcast to a MatterSubsystemRep.
    class MatterSubsystemRep& updRep();
    /// Return a read-only reference to the SubsystemRep, downcast to a MatterSubsystemRep.
    const MatterSubsystemRep& getRep() const;
    /// Generate the standard set of routines for a SimTK PIMPL handle class.
    SimTK_PIMPL_DOWNCAST(MatterSubsystem, Subsystem);
    //@}
};

} // namespace SimTK

#endif // SimTK_MATTER_SUBSYSTEM_H_
