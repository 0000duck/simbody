#ifndef SimTK_SimTKCOMMON_STUDY_H_
#define SimTK_SimTKCOMMON_STUDY_H_

/* -------------------------------------------------------------------------- *
 *                       Simbody(tm): SimTKcommon                             *
 * -------------------------------------------------------------------------- *
 * This is part of the SimTK biosimulation toolkit originating from           *
 * Simbios, the NIH National Center for Physics-Based Simulation of           *
 * Biological Structures at Stanford, funded under the NIH Roadmap for        *
 * Medical Research, grant U54 GM072970. See https://simtk.org/home/simbody.  *
 *                                                                            *
 * Portions copyright (c) 2006-15 Stanford University and the Authors.        *
 * Authors: Michael Sherman                                                   *
 * Contributors:                                                              *
 *                                                                            *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may    *
 * not use this file except in compliance with the License. You may obtain a  *
 * copy of the License at http://www.apache.org/licenses/LICENSE-2.0.         *
 *                                                                            *
 * Unless required by applicable law or agreed to in writing, software        *
 * distributed under the License is distributed on an "AS IS" BASIS,          *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *
 * See the License for the specific language governing permissions and        *
 * limitations under the License.                                             *
 * -------------------------------------------------------------------------- */

/** @file
This file declares the Study base class. **/

#include "SimTKcommon/basics.h"
#include "SimTKcommon/Simmatrix.h"
#include "SimTKcommon/internal/State.h"
#include "SimTKcommon/internal/System.h"

namespace SimTK {

//==============================================================================
//                                 STUDY
//==============================================================================
/** This is the abstract base class for all Simbody studies.

A %Study is an object that combines a System with an internal State, and 
generates as output a sequence of State values that satisfies some specified
conditions. This sequence is called a *trajectory*. For example, an Integrator
study returns a sequence of states that satisfies Newton's laws. An Assembler
study return a single State that satisfies a set of position-level constraints.
A Monte Carlo study would generate a trajectory satisfying a particular 
probability distribution.

A %Study can provide some basic information through the interface here. It can
provide a const reference to the System it is studying, the current State,
and accuracy requirements. The exact meaning of these quantities
is defined by the concrete %Study object. For any more detailed information you
must know a more-specific %Study type (such as Integrator) and downcast.

The %Study class has a public interface for users of Studies, and a pure virtual
protected interface for implementors of Studies.
**/
class SimTK_SimTKCOMMON_EXPORT Study {
public:
    /** Destructor is virtual to support derived class cleanup. **/
    virtual ~Study() = default;

    /** Return the System that is the subject of this %Study. This is only
    available as a const reference because a System is immutable during a
    %Study. **/
    const System& getSystem() const 
    {   return getSystemVirtual(); }

    /** Return a const reference to the "current" state of this %Study, with the
    precise meaning up to the concrete %Study to define. This is typically 
    the state that should be reported next; it is the logical next state of
    the trajectory being generated by the %Study. However, it is possible that
    the %Study has already progressed further than this internally; see
    getInternalState() for access to that state.
    
    The returned reference here *may* be the same as that returned by 
    getInternalState() but it does not have to be. The referenced object may 
    change from step to step so you should not assume it will remain fixed 
    during a %Study. For an Integrator, this may be an interpolated state. In
    general this is an estimated, calculated state placed into a temporary
    object so it does not make sense to provide write access. See 
    updInternalState() to get write access to meaningful internal data of 
    the %Study. **/
    const State& getCurrentState() const 
    {   return getCurrentStateVirtual(); }

    /** Return a const reference to the "internal" state of this %Study, with 
    the precise meaning up to the concrete %Study to define. This should be 
    a reference to the object that the %Study modifies internally that 
    represents the furthest progress of the trajectory. Note that it may be
    further along than what gets returned by getCurrentState(). **/
    const State& getInternalState() const 
    {   return getInternalStateVirtual(); }

    /** Return a writable reference to the "internal" state of this %Study.
    Modifying this state will affect the progression of the %Study. This is
    typically done in event handlers and during initialization. See
    getInternalState() for more information. **/
    State& updInternalState() 
    {   return updInternalStateVirtual(); }

    /** Return the current accuracy setting in use by this %Study. The precise
    meaning of this unitless parameter varies according to the concrete %Study 
    type, but it can usually be interpreted to mean something related to the 
    number of correct digits in the solution for the %Study's variables. For 
    example, 1e-3 would mean that we are requesting three correct digits, that 
    is, an accuracy of 0.1%. If this doesn't make sense for a particular 
    concrete %Study it returns `NaN`. **/
    Real getAccuracyInUse() const 
    {   return getAccuracyInUseVirtual(); }

    /** Return the current constraint tolerance in use by this %Study. The
    precise meaning of this parameter varies according to the concrete %Study
    type, but is usually the value determining how precisely constraints or
    other algebraic equations are to be satisfied. If this
    doesn't make sense for a particular concrete %Study it returns `NaN`. **/
    Real getConstraintToleranceInUse() const 
    {   return getConstraintToleranceInUseVirtual(); }

    /** Return the worst precision with which dependent quantities are computed
    for given values of the state varibles. This is typically the accelerations,
    which may be computed to machine precision by direct methods or to some
    approximation by iterative methods. **/
    Real getPrecision() const
    {   return getPrecisionVirtual(); }

    /** Return the time scale in use by this %Study. Typically this is just
    the System's default time scale. **/
    double getTimeScaleInUse() const
    {   return getTimeScaleInUseVirtual(); }

    /** Return the length scale in use by this %Study. Typically this is just
    the System's default length scale. **/
    Real getLengthScaleInUse() const
    {   return getLengthScaleInUseVirtual(); }

    /** Studies can't be copied. **/
    Study(const Study&) = delete;
    /** Studies can't be copied. **/
    Study& operator=(const Study&) = delete;

protected:
    /** Constructor is for derived class use only. **/
    Study() {}

    /** You must provide a const reference to the System you are studying. **/
    virtual const System& getSystemVirtual() const = 0;

    /** Return your %Study's notion of current state. It is fine if this is
    the same as your internal state. Note that you must return a reference so
    if you create a temporary state you must do so into an internal object that
    persists at least until the next step. If this doesn't make sense for your
    %Study you should throw an exception with a helpful message. **/
    virtual const State& getCurrentStateVirtual() const = 0; 

    /** This should be a reference to the internal object that you use to
    represent the furthest your %Study algorithm has progressed along the
    generated trajectory.  If this doesn't make sense for your %Study you 
    should throw an exception with a helpful message. **/
    virtual const State& getInternalStateVirtual() const = 0;  

    /** This should be a writable reference to the same object returned by
    getInternalState(). This should be the state that you want an event
    handler to modify to affect the subsequent trajectory. If this doesn't make
    sense for your %Study you should throw an exception with a helpful 
    message. **/
    virtual State& updInternalStateVirtual() = 0;  

    /** This should be the accuracy you are currently using, not necessarily
    regurgitating a user setting. If this doesn't make sense for your
    particular concrete %Study, just return `NaN`. Make sure your documentation
    explains exactly what is meant by "accuracy" in your %Study. **/
    virtual Real getAccuracyInUseVirtual() const = 0;

    /** This should be the constraint tolerance you are currently using, not 
    necessarily regurgitating a user setting. If this doesn't make sense for 
    your particular concrete %Study, just return `NaN`. Make sure your 
    documentation explains exactly what is meant by "constraint tolerance" in 
    your %Study. **/
    virtual Real getConstraintToleranceInUseVirtual() const = 0;

    /** The default implementation returns the System's default time scale;
    override if you have your own. 
    @see SimTK::System::setDefaultTimeScale() **/
    virtual double getTimeScaleInUseVirtual() const
    {   return getSystem().getDefaultTimeScale(); }

    /** The default implementation returns the System's default length scale;
    override if you have your own. 
    @see SimTK::System::setDefaultLengthScale() **/
    virtual Real getLengthScaleInUseVirtual() const
    {   return getSystem().getDefaultLengthScale(); }

    /** The default implementation assumes the worst-case computation of
    dependent quantities (including accelerations) is done to machine precision,
    less some allowance for roundoff and matrix computations. We use Eps^0.75
    for the default, where Eps is machine epsilon, so this is around 2e-12
    in double precision. Be sure to override this if you are computing
    accelerations using an iterative method that converges at a looser
    tolerance. **/
    virtual Real getPrecisionVirtual() const
    {   return /*Eps34*/SqrtEps; } // TODO: figure out how to change this
};

} // namespace SimTK

#endif // SimTK_SimTKCOMMON_STUDY_H_
